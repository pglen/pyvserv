<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyvreplic API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyvreplic</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3

import os, sys, threading, time

base = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(base,  &#39;..&#39;))

import sys

if sys.version_info[0] &lt; 3:
    print(&#34;Python 2 is not supported as of 1/1/2020&#34;)
    sys.exit(1)

import os, getopt, signal, select, string, time
import tarfile, subprocess, struct, platform
import socket, threading, tracemalloc, inspect

if sys.version_info[0] &lt; 3:
    import SocketServer as socketserver
else:
    import socketserver

from pyvcommon import support
from pyvcommon import pyservsup
from pyvcommon import pyclisup
from pyvcommon import pydata
from pyvcommon import pysyslog
from pyvcommon import comline
from pyvcommon import pyvhash

from pyvcommon import pyservsup, pyclisup

base = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(&#34;..&#34;,  &#39;pydbase&#39;))

from pydbase import twincore, twinchain

import pyvpacker

replicname = &#34;replic.pydb&#34;
datafname = &#34;initial.pydb&#34;
ihostfname = &#34;ihosts.pydb&#34;

MAX_DBSIZE = 20                 # Size of DB when vacuum

class Blank(): pass

class Replicator():

    def __init__(self, verbose = 0, pgdebug = 0):
        self.verbose = verbose
        self.pgdebug = pgdebug
        self.packer = pyvpacker.packbin()
        self.dbfarr = []
        self.dbdarr = []
        self.hostdarr = []

    def _print_handles(self):

        &#39;&#39;&#39; Debug helper &#39;&#39;&#39;
        open_file_handles = os.listdir(&#39;/proc/self/fd&#39;)
        print(&#39;open file handles: &#39; + &#39;, &#39;.join(map(str, open_file_handles)))

    #def softcreate(self, dbarr, fname, dbcreator):
    #
    #    &#39;&#39;&#39; create database only once &#39;&#39;&#39;
    #    xcore = None
    #    for aa in dbarr:
    #        if aa[0] == fname:
    #            xcore = aa[1]
    #            break
    #    if not xcore:
    #        xcore = dbcreator(fname)
    #        dbarr.append((fname, xcore))
    #    return xcore

    def rep_run(self):

        &#39;&#39;&#39; Main entry point for replication. &#39;&#39;&#39;

        while True:
            if self.pgdebug &gt; 5:
                print(&#34;Rep cycle&#34;, time.time())
            if self.pgdebug &gt; 5:
                print(&#34;Replicator cycle&#34;, time.time())
            ddd = os.listdir(pyservsup.globals.paydir)
            for aa in ddd:
                aaa = os.path.join(pyservsup.globals.paydir, aa)
                if not os.path.isdir(aaa):
                    continue
                #print(aaa)
                fname = os.path.join(aaa, replicname)
                if not os.path.isfile(fname):
                    continue
                self.scandir(aa)
            time.sleep(1)

    def scandir(self, dirname):

        &#39;&#39;&#39; Scan chain dir for replication data. &#39;&#39;&#39;

        wastrans = False
        fname = os.path.join(pyservsup.globals.paydir, dirname)
        rfile = os.path.join(fname, replicname)
        #print(&#34;rfile: &#34;, rfile)
        repcore = twinchain.TwinCore(rfile)
        #repcore.pgdebug = 10
        #repcore.core_verbose = 5
        dbsize = repcore.getdbsize()
        #print(&#34;dbsize&#34;, dbsize)
        for bb in range(dbsize):
            try:
                rec = repcore.get_rec(bb)
            except:
                print(&#34;Exc on get_rec&#34;, sys.exc_info())
                continue
            if not rec:
                continue;   # Deleted record
            #print(&#34;head:&#34;, rec[0], &#34;arr:&#34;, rec[1])
            arr = self.packer.decode_data(rec[1])[0]
            #print(&#34;arr:&#34;, arr)
            # Increment count:
            cntstr2 = &#34;00000&#34;
            cntstr3 = &#34;00000&#34;
            cntstr = &#34;%05d&#34; % (int(arr[&#39;count1&#39;]) + 1)
            arr[&#39;count1&#39;] = cntstr
            #print(&#34;arr:&#34;, arr)
            if  not int(arr[&#39;count2&#39;]):
                #if  int(cntstr) &gt; 1  and int(cntstr) &lt; 4:

                # condition for transmit try
                tryit =  int(arr[&#39;count3&#39;])  &gt; 0 and int(cntstr) == 6
                tryit |= int(arr[&#39;count3&#39;]) == 0 and int(cntstr) == 1

                if tryit:
                    wastrans = True
                    success = self.replicate(dirname, rec[0])
                    if success:
                        if self.pgdebug &gt; 5:
                            print(&#34;Succeeded&#34;, rec[0])
                         # Increment success count:
                        cntstr2 = &#34;%05d&#34; % (int(arr[&#39;count2&#39;]) + 1)
                        arr[&#39;count2&#39;] = cntstr2
                    else:
                        if self.pgdebug &gt; 0:
                            print(&#34;Failed&#34;, rec[0])
                         # Increment failure count:
                        cntstr3 = &#34;%05d&#34; % (int(arr[&#39;count3&#39;]) + 1)
                        arr[&#39;count3&#39;] = cntstr3
                        arr[&#39;count1&#39;] = 0
            else:
                if self.pgdebug &gt; 2:
                    print(&#34;Marked done&#34;, arr[&#39;header&#39;])

            strx = str(self.packer.encode_data(&#34;&#34;, arr))
            #print(&#34;Save rep&#34;, rec[0], strx)
            #ttt = time.time()
            ret = repcore.save_data(rec[0], strx, True)
            #print(&#34;db save %.3f&#34; % ((time.time() - ttt) * 1000) )

            # Failed? Keep it for a while
            delok = 0
            if int(cntstr3) == 0:
                if int(cntstr) &gt; 6:
                    #print(&#34;del rec:&#34;, rec[0])
                    delok = True
            else:
                if int(cntstr3) &gt; 3:
                    delok = True
            if delok:
                ret = repcore.del_rec_bykey(rec[0])

        if dbsize &gt; MAX_DBSIZE:

            if self.pgdebug &gt; 2:
                print(&#34;vacuuming&#34;, dbsize)
            if self.pgdebug &gt; 5:
                ttt = time.time()
            repcore.vacuum()
            if self.pgdebug &gt; 5:
                print(&#34;db vacuum %.3f&#34; % ((time.time() - ttt) * 1000) )

        del repcore

        if wastrans:
            if self.pgdebug &gt; 5:
                self._print_handles()

    def replicate(self, dirname, recx):

        &#39;&#39;&#39; Replicate this to all the hosts in the list. &#39;&#39;&#39;

        if self.pgdebug &gt; 2:
            print(&#34;replicate&#34;, dirname, recx)
        if type(recx) == type(b&#34;&#34;):
            recx = recx.decode()
        ret = 0
        fname = os.path.join(pyservsup.globals.paydir, dirname)
        dfname = os.path.join(fname, datafname)

        #print(&#34;dfname: &#34;, dfname)
        #if not os.path.isfile(dfname):
        #    return
        #datacore = self.softcreate(self.dbdarr, dfname, twinchain.TwinChain)
        datacore = twinchain.TwinChain(dfname)

        #print(&#34;dbsize&#34;, datacore.getdbsize())
        #print(&#34;recx&#34;, recx)
        try:
            rec = datacore.get_data_bykey(recx)
        except:
            print(&#34;Replicate: cannot get record&#34;, sys.exc_info)
        if not rec:
            #print(&#34;Empty record on replicate&#34;)
            return
        if self.pgdebug &gt; 5:
            print(&#34;rec&#34;, rec)
        #print(&#34;rex&#34;, rec[0][1][1])
        arr = self.packer.decode_data(rec[0][1][1])
        # Decorate &#39;replicated&#39; variable
        if &#39;replicate&#39; in arr[0]:
            arr[0][&#39;Replicated&#39;] += 1
        else:
            arr[0][&#39;Replicated&#39;] = 1
        #print(arr)

        pvh = pyvhash.BcData(arr[0])
        pvh.hasharr(); pvh.powarr()
        if self.pgdebug &gt; 5:
            print(&#34;pyvhash&#34;, pvh.datax, pvh.checkhash(), pvh.checkpow())
        del datacore

        # Replicate on a per host basis
        hfname = os.path.join(pyservsup.globals.myhome, ihostfname)
        #print(&#34;hfname&#34;, hfname)
        #hostcore = self.softcreate(self.hostdarr, hfname, twincore.TwinCore)
        hostcore = twincore.TwinCore(hfname)
        ret = 0
        for bb in range(hostcore.getdbsize()):
            try:
                hrec = hostcore.get_rec(bb)
            except:
                pass
            if not hrec:
                continue;       # Deleted record

            if self.pgdebug &gt; 5:
                print(&#34;transmit to host&#34;, hrec, dirname, pvh.datax[&#39;header&#39;])

            ret = self.transmit(hrec[0], dirname, pvh.datax)
        del hostcore
        return ret

    def transmit(self, hostport, dirname, data):

        &#39;&#39;&#39; Transmit to one particular host, Return True for success &#39;&#39;&#39;

        if self.pgdebug &gt; 0:
            print(&#34;Transmitting:&#34;, hostport, dirname, data[&#39;header&#39;])

        hp = hostport.decode().split(&#34;:&#34;)
        ret = 0
        hand = pyclisup.CliSup()
        try:
            respc = hand.connect(hp[0], int(hp[1]))
        except:
            print( &#34;Cannot connect to:&#34;, hp, sys.exc_info()[1])
            # Failure, log it
            pysyslog.repliclog(&#34;Cannot Connect:&#34;, hostport.decode(), dirname, data[&#39;header&#39;])
            return False

        conf = Blank()
        hand.start_session(conf)
        #print(conf.sess_key[:24])
        cresp = hand.client([&#34;user&#34;, &#34;admin&#34;], conf.sess_key)
        if self.pgdebug &gt; 5:
            print (&#34;Server user respo:&#34;, cresp)
        cresp = hand.client([&#34;pass&#34;, &#34;1234&#34;], conf.sess_key)
        if self.pgdebug &gt; 5:
            print (&#34;Server pass resp:&#34;, cresp)
        if cresp[0]  != &#34;OK&#34;:
            print(&#34;Error on connecting, invalid pass&#34;)
            cresp = hand.client([&#34;quit&#34;], conf.sess_key, False)
            hand.close()
            return ret
        cresp = hand.client([&#34;rput&#34;, dirname, data] , conf.sess_key, False)
        if cresp[0]  != &#34;OK&#34;:
            print(&#34;rput ERR Resp:&#34;, cresp)
            cresp = hand.client([&#34;quit&#34;], conf.sess_key, False)
            hand.close()
            return ret
        if self.pgdebug &gt; 2:
            print (&#34;Server rput resp:&#34;, cresp)
        cresp = hand.client([&#34;quit&#34;], conf.sess_key, False)
        #print (&#34;Server quit resp:&#34;, cresp)
        hand.close()

        # Success, log it
        pysyslog.repliclog(&#34;Replicated&#34;, hostport.decode(), dirname, data[&#39;header&#39;])

        # Success, mark record
        ret = True
        return ret

optarr =  comline.optarrlong

optarr.append ( [&#34;N&#34;,   &#34;norepl&#34;,    &#34;norepl&#34;,      0,       None, &#34;No replication (for test)&#34;] )
optarr.append ( [&#34;r:&#34;,  &#34;dataroot=&#34;, &#34;droot&#34;,  &#34;pyvserver&#34;,  None, &#34;Root for server data&#34;] )
#optarr.append ( [&#34;d:&#34;,  &#34;debug=&#34;,    &#34;pgdebug&#34;,  0,           None, &#34;Debug level (0-10)&#34;] )

if __name__ == &#39;__main__&#39;:

    conf = comline.ConfigLong(optarr)
    conf.comline(sys.argv[1:])
    # Comline processed, go

    if conf.pgdebug &gt; 5:
        conf.printvars()

    pyservsup.globals  = pyservsup.Global_Vars(__file__, conf.droot)
    pyservsup.globals.conf = conf

    rlogfile = os.path.join(pyservsup.globals.myhome, &#34;log&#34;, &#34;pyvreplic.log&#34;)
    pysyslog.init_loggers((&#34;replic&#34;, rlogfile))
    pysyslog.repliclog(&#34;Replicator started&#34;)

    print(&#34;Started replicator&#34;)
    repl = Replicator(conf.verbose, conf.pgdebug)
    repl.rep_run()

# EOF</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyvreplic.Blank"><code class="flex name class">
<span>class <span class="ident">Blank</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Blank(): pass</code></pre>
</details>
</dd>
<dt id="pyvreplic.Replicator"><code class="flex name class">
<span>class <span class="ident">Replicator</span></span>
<span>(</span><span>verbose=0, pgdebug=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Replicator():

    def __init__(self, verbose = 0, pgdebug = 0):
        self.verbose = verbose
        self.pgdebug = pgdebug
        self.packer = pyvpacker.packbin()
        self.dbfarr = []
        self.dbdarr = []
        self.hostdarr = []

    def _print_handles(self):

        &#39;&#39;&#39; Debug helper &#39;&#39;&#39;
        open_file_handles = os.listdir(&#39;/proc/self/fd&#39;)
        print(&#39;open file handles: &#39; + &#39;, &#39;.join(map(str, open_file_handles)))

    #def softcreate(self, dbarr, fname, dbcreator):
    #
    #    &#39;&#39;&#39; create database only once &#39;&#39;&#39;
    #    xcore = None
    #    for aa in dbarr:
    #        if aa[0] == fname:
    #            xcore = aa[1]
    #            break
    #    if not xcore:
    #        xcore = dbcreator(fname)
    #        dbarr.append((fname, xcore))
    #    return xcore

    def rep_run(self):

        &#39;&#39;&#39; Main entry point for replication. &#39;&#39;&#39;

        while True:
            if self.pgdebug &gt; 5:
                print(&#34;Rep cycle&#34;, time.time())
            if self.pgdebug &gt; 5:
                print(&#34;Replicator cycle&#34;, time.time())
            ddd = os.listdir(pyservsup.globals.paydir)
            for aa in ddd:
                aaa = os.path.join(pyservsup.globals.paydir, aa)
                if not os.path.isdir(aaa):
                    continue
                #print(aaa)
                fname = os.path.join(aaa, replicname)
                if not os.path.isfile(fname):
                    continue
                self.scandir(aa)
            time.sleep(1)

    def scandir(self, dirname):

        &#39;&#39;&#39; Scan chain dir for replication data. &#39;&#39;&#39;

        wastrans = False
        fname = os.path.join(pyservsup.globals.paydir, dirname)
        rfile = os.path.join(fname, replicname)
        #print(&#34;rfile: &#34;, rfile)
        repcore = twinchain.TwinCore(rfile)
        #repcore.pgdebug = 10
        #repcore.core_verbose = 5
        dbsize = repcore.getdbsize()
        #print(&#34;dbsize&#34;, dbsize)
        for bb in range(dbsize):
            try:
                rec = repcore.get_rec(bb)
            except:
                print(&#34;Exc on get_rec&#34;, sys.exc_info())
                continue
            if not rec:
                continue;   # Deleted record
            #print(&#34;head:&#34;, rec[0], &#34;arr:&#34;, rec[1])
            arr = self.packer.decode_data(rec[1])[0]
            #print(&#34;arr:&#34;, arr)
            # Increment count:
            cntstr2 = &#34;00000&#34;
            cntstr3 = &#34;00000&#34;
            cntstr = &#34;%05d&#34; % (int(arr[&#39;count1&#39;]) + 1)
            arr[&#39;count1&#39;] = cntstr
            #print(&#34;arr:&#34;, arr)
            if  not int(arr[&#39;count2&#39;]):
                #if  int(cntstr) &gt; 1  and int(cntstr) &lt; 4:

                # condition for transmit try
                tryit =  int(arr[&#39;count3&#39;])  &gt; 0 and int(cntstr) == 6
                tryit |= int(arr[&#39;count3&#39;]) == 0 and int(cntstr) == 1

                if tryit:
                    wastrans = True
                    success = self.replicate(dirname, rec[0])
                    if success:
                        if self.pgdebug &gt; 5:
                            print(&#34;Succeeded&#34;, rec[0])
                         # Increment success count:
                        cntstr2 = &#34;%05d&#34; % (int(arr[&#39;count2&#39;]) + 1)
                        arr[&#39;count2&#39;] = cntstr2
                    else:
                        if self.pgdebug &gt; 0:
                            print(&#34;Failed&#34;, rec[0])
                         # Increment failure count:
                        cntstr3 = &#34;%05d&#34; % (int(arr[&#39;count3&#39;]) + 1)
                        arr[&#39;count3&#39;] = cntstr3
                        arr[&#39;count1&#39;] = 0
            else:
                if self.pgdebug &gt; 2:
                    print(&#34;Marked done&#34;, arr[&#39;header&#39;])

            strx = str(self.packer.encode_data(&#34;&#34;, arr))
            #print(&#34;Save rep&#34;, rec[0], strx)
            #ttt = time.time()
            ret = repcore.save_data(rec[0], strx, True)
            #print(&#34;db save %.3f&#34; % ((time.time() - ttt) * 1000) )

            # Failed? Keep it for a while
            delok = 0
            if int(cntstr3) == 0:
                if int(cntstr) &gt; 6:
                    #print(&#34;del rec:&#34;, rec[0])
                    delok = True
            else:
                if int(cntstr3) &gt; 3:
                    delok = True
            if delok:
                ret = repcore.del_rec_bykey(rec[0])

        if dbsize &gt; MAX_DBSIZE:

            if self.pgdebug &gt; 2:
                print(&#34;vacuuming&#34;, dbsize)
            if self.pgdebug &gt; 5:
                ttt = time.time()
            repcore.vacuum()
            if self.pgdebug &gt; 5:
                print(&#34;db vacuum %.3f&#34; % ((time.time() - ttt) * 1000) )

        del repcore

        if wastrans:
            if self.pgdebug &gt; 5:
                self._print_handles()

    def replicate(self, dirname, recx):

        &#39;&#39;&#39; Replicate this to all the hosts in the list. &#39;&#39;&#39;

        if self.pgdebug &gt; 2:
            print(&#34;replicate&#34;, dirname, recx)
        if type(recx) == type(b&#34;&#34;):
            recx = recx.decode()
        ret = 0
        fname = os.path.join(pyservsup.globals.paydir, dirname)
        dfname = os.path.join(fname, datafname)

        #print(&#34;dfname: &#34;, dfname)
        #if not os.path.isfile(dfname):
        #    return
        #datacore = self.softcreate(self.dbdarr, dfname, twinchain.TwinChain)
        datacore = twinchain.TwinChain(dfname)

        #print(&#34;dbsize&#34;, datacore.getdbsize())
        #print(&#34;recx&#34;, recx)
        try:
            rec = datacore.get_data_bykey(recx)
        except:
            print(&#34;Replicate: cannot get record&#34;, sys.exc_info)
        if not rec:
            #print(&#34;Empty record on replicate&#34;)
            return
        if self.pgdebug &gt; 5:
            print(&#34;rec&#34;, rec)
        #print(&#34;rex&#34;, rec[0][1][1])
        arr = self.packer.decode_data(rec[0][1][1])
        # Decorate &#39;replicated&#39; variable
        if &#39;replicate&#39; in arr[0]:
            arr[0][&#39;Replicated&#39;] += 1
        else:
            arr[0][&#39;Replicated&#39;] = 1
        #print(arr)

        pvh = pyvhash.BcData(arr[0])
        pvh.hasharr(); pvh.powarr()
        if self.pgdebug &gt; 5:
            print(&#34;pyvhash&#34;, pvh.datax, pvh.checkhash(), pvh.checkpow())
        del datacore

        # Replicate on a per host basis
        hfname = os.path.join(pyservsup.globals.myhome, ihostfname)
        #print(&#34;hfname&#34;, hfname)
        #hostcore = self.softcreate(self.hostdarr, hfname, twincore.TwinCore)
        hostcore = twincore.TwinCore(hfname)
        ret = 0
        for bb in range(hostcore.getdbsize()):
            try:
                hrec = hostcore.get_rec(bb)
            except:
                pass
            if not hrec:
                continue;       # Deleted record

            if self.pgdebug &gt; 5:
                print(&#34;transmit to host&#34;, hrec, dirname, pvh.datax[&#39;header&#39;])

            ret = self.transmit(hrec[0], dirname, pvh.datax)
        del hostcore
        return ret

    def transmit(self, hostport, dirname, data):

        &#39;&#39;&#39; Transmit to one particular host, Return True for success &#39;&#39;&#39;

        if self.pgdebug &gt; 0:
            print(&#34;Transmitting:&#34;, hostport, dirname, data[&#39;header&#39;])

        hp = hostport.decode().split(&#34;:&#34;)
        ret = 0
        hand = pyclisup.CliSup()
        try:
            respc = hand.connect(hp[0], int(hp[1]))
        except:
            print( &#34;Cannot connect to:&#34;, hp, sys.exc_info()[1])
            # Failure, log it
            pysyslog.repliclog(&#34;Cannot Connect:&#34;, hostport.decode(), dirname, data[&#39;header&#39;])
            return False

        conf = Blank()
        hand.start_session(conf)
        #print(conf.sess_key[:24])
        cresp = hand.client([&#34;user&#34;, &#34;admin&#34;], conf.sess_key)
        if self.pgdebug &gt; 5:
            print (&#34;Server user respo:&#34;, cresp)
        cresp = hand.client([&#34;pass&#34;, &#34;1234&#34;], conf.sess_key)
        if self.pgdebug &gt; 5:
            print (&#34;Server pass resp:&#34;, cresp)
        if cresp[0]  != &#34;OK&#34;:
            print(&#34;Error on connecting, invalid pass&#34;)
            cresp = hand.client([&#34;quit&#34;], conf.sess_key, False)
            hand.close()
            return ret
        cresp = hand.client([&#34;rput&#34;, dirname, data] , conf.sess_key, False)
        if cresp[0]  != &#34;OK&#34;:
            print(&#34;rput ERR Resp:&#34;, cresp)
            cresp = hand.client([&#34;quit&#34;], conf.sess_key, False)
            hand.close()
            return ret
        if self.pgdebug &gt; 2:
            print (&#34;Server rput resp:&#34;, cresp)
        cresp = hand.client([&#34;quit&#34;], conf.sess_key, False)
        #print (&#34;Server quit resp:&#34;, cresp)
        hand.close()

        # Success, log it
        pysyslog.repliclog(&#34;Replicated&#34;, hostport.decode(), dirname, data[&#39;header&#39;])

        # Success, mark record
        ret = True
        return ret</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyvreplic.Replicator.rep_run"><code class="name flex">
<span>def <span class="ident">rep_run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Main entry point for replication.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rep_run(self):

    &#39;&#39;&#39; Main entry point for replication. &#39;&#39;&#39;

    while True:
        if self.pgdebug &gt; 5:
            print(&#34;Rep cycle&#34;, time.time())
        if self.pgdebug &gt; 5:
            print(&#34;Replicator cycle&#34;, time.time())
        ddd = os.listdir(pyservsup.globals.paydir)
        for aa in ddd:
            aaa = os.path.join(pyservsup.globals.paydir, aa)
            if not os.path.isdir(aaa):
                continue
            #print(aaa)
            fname = os.path.join(aaa, replicname)
            if not os.path.isfile(fname):
                continue
            self.scandir(aa)
        time.sleep(1)</code></pre>
</details>
</dd>
<dt id="pyvreplic.Replicator.replicate"><code class="name flex">
<span>def <span class="ident">replicate</span></span>(<span>self, dirname, recx)</span>
</code></dt>
<dd>
<div class="desc"><p>Replicate this to all the hosts in the list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replicate(self, dirname, recx):

    &#39;&#39;&#39; Replicate this to all the hosts in the list. &#39;&#39;&#39;

    if self.pgdebug &gt; 2:
        print(&#34;replicate&#34;, dirname, recx)
    if type(recx) == type(b&#34;&#34;):
        recx = recx.decode()
    ret = 0
    fname = os.path.join(pyservsup.globals.paydir, dirname)
    dfname = os.path.join(fname, datafname)

    #print(&#34;dfname: &#34;, dfname)
    #if not os.path.isfile(dfname):
    #    return
    #datacore = self.softcreate(self.dbdarr, dfname, twinchain.TwinChain)
    datacore = twinchain.TwinChain(dfname)

    #print(&#34;dbsize&#34;, datacore.getdbsize())
    #print(&#34;recx&#34;, recx)
    try:
        rec = datacore.get_data_bykey(recx)
    except:
        print(&#34;Replicate: cannot get record&#34;, sys.exc_info)
    if not rec:
        #print(&#34;Empty record on replicate&#34;)
        return
    if self.pgdebug &gt; 5:
        print(&#34;rec&#34;, rec)
    #print(&#34;rex&#34;, rec[0][1][1])
    arr = self.packer.decode_data(rec[0][1][1])
    # Decorate &#39;replicated&#39; variable
    if &#39;replicate&#39; in arr[0]:
        arr[0][&#39;Replicated&#39;] += 1
    else:
        arr[0][&#39;Replicated&#39;] = 1
    #print(arr)

    pvh = pyvhash.BcData(arr[0])
    pvh.hasharr(); pvh.powarr()
    if self.pgdebug &gt; 5:
        print(&#34;pyvhash&#34;, pvh.datax, pvh.checkhash(), pvh.checkpow())
    del datacore

    # Replicate on a per host basis
    hfname = os.path.join(pyservsup.globals.myhome, ihostfname)
    #print(&#34;hfname&#34;, hfname)
    #hostcore = self.softcreate(self.hostdarr, hfname, twincore.TwinCore)
    hostcore = twincore.TwinCore(hfname)
    ret = 0
    for bb in range(hostcore.getdbsize()):
        try:
            hrec = hostcore.get_rec(bb)
        except:
            pass
        if not hrec:
            continue;       # Deleted record

        if self.pgdebug &gt; 5:
            print(&#34;transmit to host&#34;, hrec, dirname, pvh.datax[&#39;header&#39;])

        ret = self.transmit(hrec[0], dirname, pvh.datax)
    del hostcore
    return ret</code></pre>
</details>
</dd>
<dt id="pyvreplic.Replicator.scandir"><code class="name flex">
<span>def <span class="ident">scandir</span></span>(<span>self, dirname)</span>
</code></dt>
<dd>
<div class="desc"><p>Scan chain dir for replication data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scandir(self, dirname):

    &#39;&#39;&#39; Scan chain dir for replication data. &#39;&#39;&#39;

    wastrans = False
    fname = os.path.join(pyservsup.globals.paydir, dirname)
    rfile = os.path.join(fname, replicname)
    #print(&#34;rfile: &#34;, rfile)
    repcore = twinchain.TwinCore(rfile)
    #repcore.pgdebug = 10
    #repcore.core_verbose = 5
    dbsize = repcore.getdbsize()
    #print(&#34;dbsize&#34;, dbsize)
    for bb in range(dbsize):
        try:
            rec = repcore.get_rec(bb)
        except:
            print(&#34;Exc on get_rec&#34;, sys.exc_info())
            continue
        if not rec:
            continue;   # Deleted record
        #print(&#34;head:&#34;, rec[0], &#34;arr:&#34;, rec[1])
        arr = self.packer.decode_data(rec[1])[0]
        #print(&#34;arr:&#34;, arr)
        # Increment count:
        cntstr2 = &#34;00000&#34;
        cntstr3 = &#34;00000&#34;
        cntstr = &#34;%05d&#34; % (int(arr[&#39;count1&#39;]) + 1)
        arr[&#39;count1&#39;] = cntstr
        #print(&#34;arr:&#34;, arr)
        if  not int(arr[&#39;count2&#39;]):
            #if  int(cntstr) &gt; 1  and int(cntstr) &lt; 4:

            # condition for transmit try
            tryit =  int(arr[&#39;count3&#39;])  &gt; 0 and int(cntstr) == 6
            tryit |= int(arr[&#39;count3&#39;]) == 0 and int(cntstr) == 1

            if tryit:
                wastrans = True
                success = self.replicate(dirname, rec[0])
                if success:
                    if self.pgdebug &gt; 5:
                        print(&#34;Succeeded&#34;, rec[0])
                     # Increment success count:
                    cntstr2 = &#34;%05d&#34; % (int(arr[&#39;count2&#39;]) + 1)
                    arr[&#39;count2&#39;] = cntstr2
                else:
                    if self.pgdebug &gt; 0:
                        print(&#34;Failed&#34;, rec[0])
                     # Increment failure count:
                    cntstr3 = &#34;%05d&#34; % (int(arr[&#39;count3&#39;]) + 1)
                    arr[&#39;count3&#39;] = cntstr3
                    arr[&#39;count1&#39;] = 0
        else:
            if self.pgdebug &gt; 2:
                print(&#34;Marked done&#34;, arr[&#39;header&#39;])

        strx = str(self.packer.encode_data(&#34;&#34;, arr))
        #print(&#34;Save rep&#34;, rec[0], strx)
        #ttt = time.time()
        ret = repcore.save_data(rec[0], strx, True)
        #print(&#34;db save %.3f&#34; % ((time.time() - ttt) * 1000) )

        # Failed? Keep it for a while
        delok = 0
        if int(cntstr3) == 0:
            if int(cntstr) &gt; 6:
                #print(&#34;del rec:&#34;, rec[0])
                delok = True
        else:
            if int(cntstr3) &gt; 3:
                delok = True
        if delok:
            ret = repcore.del_rec_bykey(rec[0])

    if dbsize &gt; MAX_DBSIZE:

        if self.pgdebug &gt; 2:
            print(&#34;vacuuming&#34;, dbsize)
        if self.pgdebug &gt; 5:
            ttt = time.time()
        repcore.vacuum()
        if self.pgdebug &gt; 5:
            print(&#34;db vacuum %.3f&#34; % ((time.time() - ttt) * 1000) )

    del repcore

    if wastrans:
        if self.pgdebug &gt; 5:
            self._print_handles()</code></pre>
</details>
</dd>
<dt id="pyvreplic.Replicator.transmit"><code class="name flex">
<span>def <span class="ident">transmit</span></span>(<span>self, hostport, dirname, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Transmit to one particular host, Return True for success</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transmit(self, hostport, dirname, data):

    &#39;&#39;&#39; Transmit to one particular host, Return True for success &#39;&#39;&#39;

    if self.pgdebug &gt; 0:
        print(&#34;Transmitting:&#34;, hostport, dirname, data[&#39;header&#39;])

    hp = hostport.decode().split(&#34;:&#34;)
    ret = 0
    hand = pyclisup.CliSup()
    try:
        respc = hand.connect(hp[0], int(hp[1]))
    except:
        print( &#34;Cannot connect to:&#34;, hp, sys.exc_info()[1])
        # Failure, log it
        pysyslog.repliclog(&#34;Cannot Connect:&#34;, hostport.decode(), dirname, data[&#39;header&#39;])
        return False

    conf = Blank()
    hand.start_session(conf)
    #print(conf.sess_key[:24])
    cresp = hand.client([&#34;user&#34;, &#34;admin&#34;], conf.sess_key)
    if self.pgdebug &gt; 5:
        print (&#34;Server user respo:&#34;, cresp)
    cresp = hand.client([&#34;pass&#34;, &#34;1234&#34;], conf.sess_key)
    if self.pgdebug &gt; 5:
        print (&#34;Server pass resp:&#34;, cresp)
    if cresp[0]  != &#34;OK&#34;:
        print(&#34;Error on connecting, invalid pass&#34;)
        cresp = hand.client([&#34;quit&#34;], conf.sess_key, False)
        hand.close()
        return ret
    cresp = hand.client([&#34;rput&#34;, dirname, data] , conf.sess_key, False)
    if cresp[0]  != &#34;OK&#34;:
        print(&#34;rput ERR Resp:&#34;, cresp)
        cresp = hand.client([&#34;quit&#34;], conf.sess_key, False)
        hand.close()
        return ret
    if self.pgdebug &gt; 2:
        print (&#34;Server rput resp:&#34;, cresp)
    cresp = hand.client([&#34;quit&#34;], conf.sess_key, False)
    #print (&#34;Server quit resp:&#34;, cresp)
    hand.close()

    # Success, log it
    pysyslog.repliclog(&#34;Replicated&#34;, hostport.decode(), dirname, data[&#39;header&#39;])

    # Success, mark record
    ret = True
    return ret</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyvreplic.Blank" href="#pyvreplic.Blank">Blank</a></code></h4>
</li>
<li>
<h4><code><a title="pyvreplic.Replicator" href="#pyvreplic.Replicator">Replicator</a></code></h4>
<ul class="">
<li><code><a title="pyvreplic.Replicator.rep_run" href="#pyvreplic.Replicator.rep_run">rep_run</a></code></li>
<li><code><a title="pyvreplic.Replicator.replicate" href="#pyvreplic.Replicator.replicate">replicate</a></code></li>
<li><code><a title="pyvreplic.Replicator.scandir" href="#pyvreplic.Replicator.scandir">scandir</a></code></li>
<li><code><a title="pyvreplic.Replicator.transmit" href="#pyvreplic.Replicator.transmit">transmit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>